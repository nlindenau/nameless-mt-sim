
/***
* Name: bus_model_timetable_ed
* Author: gabrielcramer
* Description: 
* Tags: Tag1, Tag2, TagN
***/

model traffic

// #########################
// ##### GLOBAL SPECIES ####
// #########################

// the global species is effectively the environment in the ABM in the GAMA platofrm. It is where we define universal variables, the way in which the agents are
// created, and global reflexes, or behaviours of the environment. For instance, a bus as an agent might have the reflex to move, but we define the reflex to reproduce the buses
// according to a timetable in the global environment because it is a universal feature of the simulation rather than a behaviour of individual agents. 

global {
   
   // We start by entering the data. We need roads and bus stops. We do not need the zones or the bounds, but they are helpful. The zones give a sense of perspective for the model.
   // they are the HSL zones. Originally we thought we could influence the congestion coefficients by zones. But now they are just helpful for visualisation. 
   // to generalise the model input datasets we include the processing workflow in the project documentation.
   
   // bus stops and roads and zones shapefiles - they're were separate routes, but are merged into one file. The attribute data defines the ID of the route and stops.
	file stops_shapefile <- file("/Users/gabrielcramer/Desktop/GAMA_input/stops/merged_stops.shp");
	file roads_shapefile <- file("/Users/gabrielcramer/Desktop/GAMA_input/routes/merged_routes.shp");	
	file zones_shape <- file("/Users/gabrielcramer/Desktop/GAMA_input/zones/hsl_ABC.shp");
	
	// the next data input is the timetable. the time table has three columns - hour, minute, second. We created it as a dummy timetable. It is not real.
	// future model refinement would include reading a GTFS file, or the relevant tables from a GTFS file into GAMA and selecting the relevant fields in the code. 
	// however, in the time limitations of this project, we were not able to implement this, so the dummy timetable represents pre-porcessing in excel/R, etc.
	file mock_timetable <- file("/Users/gabrielcramer/Desktop/GAMA_input/timetable/timetable.csv");
	
	// input formatting - to turn the input data into usable formats in the model we need to turn the road shapefiles (lines) into a graph, and add the possibility of playing
	//with the graph edge wegihts. We also need to give a spatial boundary to the model. We could use the road shapefile, but this is restrictive in the generalisation of the model
	// therefore we use the zones are the envelope - the spatial extent of the model. 
	
	graph road_network; // creates a graph from the road netwok as a variable, declares the type. 
	geometry shape <- envelope(zones_shape); // bounds - could use road shapefile too. 
    map<road,float> road_weights; // road weights
    matrix timetable <- matrix(mock_timetable);
    
    
    // Now we define some universal variables - or base variables, like the base speed of the buses, for example. Reflexes in the bus species and the bus stop species are able to alter
    // these variables. It is also important that we define some variables in the global environment if we want to added them as user interactive parameters in the simulation. For example, 
    // we may want to change the base speed of the bus when running the simulation, so we can add that as a paramter later on in the experiment section...but only if the variableis defined
    // here first.
    
    float step <- 1 #seconds; // time step for the model. this is an important variable and defines the fact that we are running the model by seconds. 
    float agent_speed <- 30.0 #km/#h;  // agent speed - base level
    int seconds <- 60; // this is used as the time step at which the number of passengers at the bus stop updates in a later reflex. defined here so it can be a parameter
    int grow_upper_limit <- 3; // this is the upper limit on the number of passengers that can join a bus stop at each time step (defined by the parameter 'seconds'. 
    
    int number_of_cars <- 10; // number of cars on the road at the start of the simulation - a parameter.
    
    // we should also define some variable that influence the set up of the environment - e.g. the time frame
    date starting_date <- date([2020,5,12,6,0,0]); // start sim
    date end_date <- date([2020,5,12,18,0,0]); // end sim
    int traffic_am <- 8; // parameter - morning rush hour
    int traffic_pm <- 16; // evening rush hour
    float rush_hour_delay <- 0.5; // how much the bus slows down during the rush hour. a parameter
    
    // reflext to stop the sim at end date - so we don't have an endless loop. 
    reflex stop_simulation when: (current_date = end_date) {
        do pause ;
    } 
    
    // initialisation commands the sim to create the species.     
    init {
    	
    create road from: roads_shapefile with: [route_id::read("NUMERO"), direction::read("SUUNTA")]; // creates the roads from the file and selects attributes to read into the species
    road_network <- as_edge_graph(road); // the variable road_network is created as a graph.
    
    create bstops from: stops_shapefile with:[stops::read("stop_seque"), route_ids::read("REITTI"), direction::read("SUUNTA")]; // creates the stops 
    // and reads the attribute field (sequence number)
    
    //create zones
    create zones from: zones_shape with: [zone::read("Zone")]; 
    
    // this is a more complicated create - we create cars and give them some starting attributes.
    // the point of the cars is to behave randomly, but normally as cars might. as they move they give weight to the road, and slow the bus down on the road. 
    create car number: number_of_cars { //number of cars as defined by the relevant parameter
    	location <- one_of(bstops).location; //random start locations - one of the bus stops
    	vehicle_length <- 3.0; // how many meters they take up on the road
    	speed_coeff <- 1.2 - (rnd(400)/1000); // how fast the cars go - random number within the bounds of the speed limits
    	final_target <- one_of(bstops).location; // defines a random target for the cars. 
    }
    
    // you'll notice this initialisation stage doesn't create the buses... that is on purpose.
    
    }
    
    // update the road speed - by adjusting the weights. this relex defines a behaviour of the eenvironment to update the road weights depending on how many cars are on the section
    reflex update_road_speed  {
    road_weights <- road as_map (each::each.shape.perimeter / each.speed_coeff);
    road_network <- road_network with_weights road_weights;
  	}

    // The Buses - reflex in the global environment that creates the buses. the point is that we can attach conditions for the creation of buses at specific times
    // we access the hour and minute columns of the timetable matrix and when they correspond to current time and minutes in the simulation, it creates a but at the start of the route
    // the second specification is there so it doesn't create a bus at every second of the current minute. 
    reflex reproduce when: column_at(timetable, 0) contains current_date.hour and (column_at(timetable, 1) contains current_date.minute and current_date.second = 0) { //looks into the timetable
    // and compares with the current time. if there is a match, a bus is produced.
    	create bus number: 1 {
    	location <- any_location_in(one_of(bstops where (each.stops="1" and each.route_ids = "1064" ))); // starts the bus at the first stop of a particular route 
    	next_stop <- 0; // sets the initial next stop value (this is updates in the bus species behaviour
    	starting_date <- current_date; // sets the start date to current time - important for the bus species reflexes
    	start_time <- true;// sets it to true so it it starts moving
    	next_stop <- next_stop + 1;
    	ask bus{
    		target <- any_location_in(at(bstops,next_stop)); // sets first target to the next stop. 
    	}
    	}	
    	}
    // replicate the reflex to create a new bus at the correct time, but for a different route. 	
    reflex reproduce2 when: column_at(timetable, 0) contains current_date.hour and (column_at(timetable, 1) contains current_date.minute and current_date.second = 0) {
    	create bus number: 1 {
    	location <- any_location_in(one_of(bstops where (each.stops="1" and each.route_ids = "1500" ))); // starts the bus at the first stop. 
    	next_stop <- 25;
    	starting_date <- current_date;
    	start_time <- true;// sets it to true so it it starts moving
    	next_stop <- next_stop + 1;
    	ask bus{
    		target <- any_location_in(at(bstops,next_stop));
    	}
    	}	
    	}
    
}

// ##########################
// #### SPECIES BUILDING ####
// ##########################

// Now we have built the global species - the environment - we can start building the individual species. In fact, describing it this way, as a linear development pattern is misleading
// the global environment, the species and the experiement are all built in tandem and interact with and depend on each other. the development process is, therefore, highly iterative. 
// as we added new behaviours to one species, we needed to adapt the global species to handle the new behaviour, and we also have to rework other agent species to account for the new ways
// of interacting. That said, we read the code top to bottom, naturally, next....the bus species. 


// species = bus, which has the skillset [moving] which gives it some inherent skills
species bus skills:[moving]{  
	// as with the global species, we start by defining some basic variables for the species that we use in the reflexes  
    rgb color <- #green; // basic colour value
    point target; // the attribute containing information about where the bus should go next. 
    bool start_time <- false; // this is false because in the reflex we set it to true - prevents automatic start?
    bool end_time <- true; // while it is true the bus keeps trying to reach the end. 
    int trip_count;  // counts the number of trips the bus makes.
    int next_stop; // variable that gets updated so the bus can progress to each sequential stop.
    
    point final_target <-  any_point_in(at(bstops, length(bstops)-1)); // this sets the final target of the bus. I.e. the end stop.
    float speed; //this is a changeable speed variable.
    list people_waiting; 

    //start moving this time
    reflex start_t when: current_date = starting_date{
    	start_time <- true; // essentially this starts the bus from the first stop immediately. by setting the start time to true, we can evaluation in leave reflex to see
    	// if the start time is true. If it is, then the bus can move. 
    }
    
    //movement stops at this time and writes number of trips to the console. stops at the time of the end time parameter. 
    reflex end_t when: current_date = end_date{
    	end_time <- false;
    	write("Nr of complete trips:"+ trip_count); 
    	write("End time: " + current_date);
    }
   
   // a crucial reflex that tells the bus when to start moving - when to leave the current stop. 
   reflex leave when: (target = nil)  and start_time and (location != final_target) { // boolean expression - when there is no target, the start time is true, and the location is not
   // the final target, the bus does the following
		next_stop <- next_stop+1; // next stop is moved one step on
		target <- any_location_in(at(bstops,next_stop)); //the target is updates to the next stop
		
		write("Departure from stop " + next_stop + ": " + current_date); // writes the start time to the console
		
		// if clause to change the speed of the bus during the peak hours, taking into account the delay coeeficient. 
		if (current_date.hour = traffic_am or current_date.hour = traffic_pm){
			speed <- agent_speed*(1-rush_hour_delay); // so that closer to 1 give a bigger delay
		}else { // if not the rush hours then the speed is the normal baseline agent speed
			speed <- agent_speed;
		}
		write("Speed km/h:"+ speed*3.6); // writes speed of trip to console.
		
	}
	    
    //reflex to move on route until end is true    
    reflex move when: target != nil and end_time{ 
    	//this line says go to target (next stop) using the road network, rather than a straight line.
   		 do goto target:target  on: road_network move_weights: road_weights; 
    
    	//When the bus is close to the stop, it slows down to stop/pick up passengers.
    	if(location distance_to target <50){
    		speed <- 10 #km/#h;
    	}else{
    		speed <- agent_speed;
    	}
    
    	// if the location is the target, the bus has arrived at a stop and it tells us in the console
   		 if (location = target) {  
        	target <- nil;
        	write("Arrival at stop " + (next_stop+1) + ": " + current_date); // writes departure time to console
   		 } 
    
    }
    
    
    // defines visulaisation parameters of the bus. A green circle with a black border that changes to orange when the speed slows below 25kph.
    aspect default{ 
    draw circle(100) color: (speed > 25 #km / #h) ? #green : #orange border: #black;
    //draw circle(100) color: color border: #black;
    }
    
}

// now for the road species. The road, although it doesn't move, is still a species. If you are reading this top to bottom, then you have already seen an interaction between species
// when the bus is told to move it is told to move along the road species

// new species - road/route
species road skills: [skill_road_node]{
  string route_id;
  string direction;
  float capacity <- 1 + shape.perimeter/30; //Capacity of the road considering its perimeter
  int nb_people <- 0 update: length(car at_distance 1); //Number of people on the road
  float speed_coeff <- 1.0 update:  exp(-nb_people/capacity) min: 0.1; //Speed coefficient computed using the number of people on the road and the capicity of the road
  
  //visualisation parameteres
   aspect default {
    draw shape color: #black; // draws the shape as the shape
    }
}

// lots of the road attributes, like the weights, were defined in the global species, so we it looks quite short in the agent definition. However, the bus stop species is a bt longer 
// because it interacts with the buses in more complicated ways. Due to the movement and the timetabling, the buses were the most complex species, thoguh. 

// new species - bus stops
species bstops {
	rgb color <- #blue;
	string stops; // when it reads the attribute as a string
	string route_ids;
	string direction;
	float probability_grow; // probability that at each step the passenger number will grow
	int waiting <- 0; // base number of people waiting at each stop
	int grow_by <- rnd(0, grow_upper_limit); // generate random number between 0 and x
	string zone;
	int counter <- 0;
	date stop_date;
	
	// the number of passengers at a stop is not fixed. People arrive at the bus stop and wait for the bus to pick them up.
	// this reflex grows the number of passengers waiting at the bus stop every time step (defined as seconds in the global).
	reflex grow_passengers when: every(seconds #s) {
		waiting <- (waiting + grow_by);
	}
	
	// the bus needs to pick the passengers up, so the bus stop asks the bus to pick them up. If there are more than 0 passengers waiting at the stop, when the bus comes within
	// 10 meters of the stop, it picks them up. this is represented by the number of people at the stop reverting to 0. 
	reflex passenger_pick_up {
		ask bus{
			if(location distance_to myself<10){
				myself.waiting <- 0;
			}
		}
	}
	
	// we wanted to have a visual way of showing that too many people were waiting at the stop. 
	// so we built this reflex - if there are more than 10 people at the stop it changes the colour parameter to red, else it is blue. 
	reflex change_colour{
		if (waiting > 10) {
			color <- #red;
		}else {
			color <- #blue;
		}
	}
	
		
	//visualisation parameters
    aspect default {
    draw circle(50) color: color border: #black;
    }
}

//zones species - a simple species to represent the HSL zones.
species zones{
  string zone;
  
  aspect default {
    if (zone="A"){
      draw shape  color: #white border: #black ;  
    }
    if (zone="B"){
      draw shape  color: #white border: #black;  
    }
      if (zone="C"){
        draw shape  color: #white border: #black; 
      }
    }
}

// the car species we define below is created to add congestion to the route. When a car is on a segment of road it influences the weights of that edge, which in turn slows down
// the buses on the segement of road. In essence the cars move around at random and at random speeds, simulating the random probability that a bus will encoutner congestion. 
// to account for non-random congestion, i.e. rush hours, we have built in rush hours into the bus species itself.

// new species - car
species car skills: [advanced_driving]{ // the cars use an inbuilt set of functionalities called advanced driving. We used these to simplify the code and give the cars capabilities that
//worked with predefined attributes, or inherent skills, rather than coding them from scratch. 
	rgb color <- #yellow;
	int start;
	int end;
	point target;
	float speed <- rnd(1,100) #km / #h;
	
	// this reflex give the car impetus to move by giving it a target...
	reflex time_to_go when: final_target = nil {
		current_path <- compute_path(graph: road_network, target: one_of(bstops));
	}
	
	//...while this reflex allows it to move, by telling it to move along the roads to the target.
	reflex move when: final_target != nil {
		do goto(target: one_of(bstops), on: road_network, return_path: true);
		
		if (location = target) { // if the location is the target, it is the arrival 
        target <- nil;
        
        }
	}
	
	//visualisation.
	aspect default {
		draw square(50) color: color border: #black;
	}
}

// ########################
// #### THE EXPERIMENT ####
// ########################

// the experiement parameters are for  running the model - they tell the model what to display and define which global parameters the user can change. In the interestes of general
// solutions we have built in user defined parameters for the input data, and so the user can run different scenarios we have made as made parameters available to adjust as is 
// practicable, such as, base bus speed, start and end times of the simulation, when the rush hours occur, how many passengers can arrive at a bus stop at any given time step, 
// how big that time step is, and the number of cars clogging up the roads. 

//it seems usual in the tutorials to define the parameters first, and then the outputs (ways of monitoring and measuring the simulation, and then finally we define what to 
// display in the simulaiton itself

// experiment setup
experiment main_experiment type:gui{ // type visual for the animation
	
	/////////////////
	// PARAMETERS //
	///////////////
	
	// define all the parameters we might want to change in the model as the user
	// the category would be an interesting one to change if we wanted to make so user online could input their own routes...maybe. 
	parameter "Speed (m/s): " var: agent_speed min: 0.00 max: 100.00 category: "Bus" ;
	parameter "Start: " var: starting_date category: "Bus";
	parameter "End: " var: end_date category: "Bus";
	parameter "Morning rush hour: " var: traffic_am min: 0 max: 23 category: "Bus" ;
	parameter "Afternoon rush hour: " var: traffic_pm min: 0 max: 23 category: "Bus" ;
	parameter "Rush hour delay factor: " var: rush_hour_delay min: 0.0 max: 1.0 category: "Bus" ;
	
	// parameters to change shapefile input
	parameter "Shapefile for the stops:" var: stops_shapefile category: "GIS" ;
    parameter "Shapefile for the roads:" var: roads_shapefile category: "GIS" ;
    //parameter "Shapefile for the bounds:" var: bounds category: "GIS" ;
    
    // parameter to change timetable
    parameter "Timetable:" var: mock_timetable category: "Timetable" ;
    
    // parameters to adjust the passengers at the bus stop
    parameter "Max. passenger increase per step" var: grow_upper_limit category: "Bus Stop";
    parameter "Passenger accumulation time step (seconds)" var: seconds category: "Bus Stop";
    
    // parameter to adjust the number of cars on the road
    parameter "Number of cars on the road at the start of the simulation" var: number_of_cars category: "Traffic";
	
	// sets the speed slider to the initial point - real time
    float minimum_cycle_duration <- 0.1;
    
    //////////////
    // OUTPUTS //
    ////////////
    
    // output into the gui
    output {
    // displays a window with these values that track through the model
    monitor "Current time" value: current_date;
    //monitor "Current hour" value: current_date.hour;
    //monitor "Current minute" value: current_date.minute;
    monitor "Speed" value: agent_speed refresh: every(5 #s);
    
    inspect "Passengers Waiting" value: bstops attributes: ["waiting"] type: table;
    
    //////////////
    // DISPLAY //
    ////////////
    
    // display in the visulation window
    display map {
        species zones;
        species road;
        species bstops;
        species bus;
        species car;
         
    }
    }
}

